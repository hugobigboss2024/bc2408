#4method
static final 變量:
特點:
在類加載時就初始化,並且值不可變。
可以在類中直接訪問,不需要創建對象。
通常用於定義常量。
適用情況:
在整個程序中需要使用的不變數值,如 Math.PI、數學公式、程序配置參數等。
static 變量:
特點:
在類加載時就初始化,屬於整個類,不屬於任何對象。
可以在類中直接訪問,也可以通過對象訪問。
生命週期與類相同,直到程序終止。
適用情況:
需要在多個方法或多個對象之間共享的數據,如累計統計值、全局配置等。
final 變量:
特點:
值一經賦值後不可改變。
可以是 static 的,也可以是非 static 的。
適用情況:
表示常量或者需要在創建時就確定值的屬性,如身份證號、產品編號等。
non-static、non-final 變量:
特點:
屬於對象,每個對象都擁有自己的副本。
可以在對象創建時初始化,也可以在後續賦值。
生命週期與對象相同,對象被釋放時變量也隨之消失。
適用情況:
表示對象的動態屬性,會隨著對象的變化而變化,如姓名、年齡、地址等。
總結來說:

static final 適用於定義整個程序中不變的常量。
static 適用於定義屬於類,需要在多個方法或對象之間共享的變量。
final 適用於定義在創建時就確定值,且之後不可改變的變量。
non-static、non-final 適用於定義屬於對象,隨對象變化而變化的動態屬性。
您可以根據需求,選擇使用不同類型的變量,以滿足程序的設計需求。
#構造方法(Constructors)和方法(Methods)區別
定義:
構造方法是用於創建對象並初始化對象狀態的特殊方法。
方法是用於實現特定功能的普通代碼塊。
命名:
構造方法必須與類名相同。
方法可以有任意名稱,但遵循命名規範。
返回值:
構造方法沒有返回值類型,包括void。
方法可以有返回值類型,也可以是void。
調用時機:
構造方法在創建對象時自動被調用,無需手動調用。
方法需要手動調用才會執行。
目的:
構造方法的目的是創建對象並初始化其成員變量。
方法的目的是實現特定的功能。
重載:
構造方法可以被重載,提供多種初始化對象的方式。
方法也可以被重載,提供多種功能實現的方式。
訪問控制符:
構造方法的訪問控制與類的訪問控制一致。
方法可以有自己的訪問控制符。
this關鍵字:
構造方法可以使用this()調用其他構造方法。
方法可以使用this.調用其他方法和成員變量。
總的來說,構造方法是用於創建對象並初始化對象狀態,而方法是用於實現特定的功能。二者雖然都是類中的成員,但定義、行為和使用場景有一定的區別。
#構造方法(Constructors)、方法(Methods)以及面向對象編程(OOP)關係
與對象創建的關係:
構造方法是用於創建對象並初始化對象狀態的特殊方法。
在面向對象編程中,我們通過創建對象來使用類的功能和屬性。
與對象行為的關係:
方法是實現類的行為和功能的代碼塊。
在面向對象編程中,我們通過調用對象的方法來執行相應的操作和實現需求。
與封裝的關係:
構造方法和方法都可以根據需要設置訪問控制權限(public、protected、default、private)。
這體現了面向對象編程中的封裝特性,隱藏了對象的內部實現細節。
與繼承的關係:
子類可以繼承父類的方法,並可以重寫(Overriding)或擴展這些方法。
子類可以調用父類的構造方法,並可以定義自己的構造方法。
與多態的關係:
方法的重載(Overloading)和重寫(Overriding)體現了多態性。
通過多態,可以根據不同的對象類型,執行不同版本的方法。
與抽象的關係:
抽象方法沒有方法體,需要在具體的子類中實現。
抽象類可以有構造方法,用於初始化子類對象的狀態。
綜上所述,Java 中的構造方法和方法是面向對象編程(OOP)的重要組成部分。它們共同參與對象的創建、行為實現、封裝、繼承和多態等OOP特性的體現,是OOP思想在Java語言中的具體體現。